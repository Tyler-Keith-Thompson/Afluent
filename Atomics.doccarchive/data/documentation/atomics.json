{"hierarchy":{"paths":[[]]},"topicSections":[{"identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/ManagedAtomic","doc:\/\/Atomics\/documentation\/Atomics\/UnsafeAtomic","doc:\/\/Atomics\/documentation\/Atomics\/ManagedAtomicLazyReference","doc:\/\/Atomics\/documentation\/Atomics\/UnsafeAtomicLazyReference"],"title":"Atomic Container Types","anchor":"Atomic-Container-Types"},{"anchor":"Memory-Orderings","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/AtomicLoadOrdering","doc:\/\/Atomics\/documentation\/Atomics\/AtomicStoreOrdering","doc:\/\/Atomics\/documentation\/Atomics\/AtomicUpdateOrdering"],"title":"Memory Orderings"},{"anchor":"Atomic-Value-Protocols","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/AtomicValue","doc:\/\/Atomics\/documentation\/Atomics\/AtomicInteger","doc:\/\/Atomics\/documentation\/Atomics\/AtomicReference","doc:\/\/Atomics\/documentation\/Atomics\/AtomicOptionalWrappable"],"title":"Atomic Value Protocols"},{"title":"Atomic Storage Representations","anchor":"Atomic-Storage-Representations","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/AtomicStorage","doc:\/\/Atomics\/documentation\/Atomics\/AtomicIntegerStorage","doc:\/\/Atomics\/documentation\/Atomics\/AtomicRawRepresentableStorage","doc:\/\/Atomics\/documentation\/Atomics\/AtomicReferenceStorage","doc:\/\/Atomics\/documentation\/Atomics\/AtomicOptionalReferenceStorage"]},{"title":"Fences","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/atomicMemoryFence(ordering:)"],"anchor":"Fences"},{"anchor":"Value-Types","title":"Value Types","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/DoubleWord"]},{"generated":true,"title":"Structures","anchor":"Structures","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/AtomicOptionalRawRepresentableStorage"]},{"anchor":"Extended-Modules","identifiers":["doc:\/\/Atomics\/documentation\/Atomics\/Swift"],"generated":true,"title":"Extended Modules"}],"sections":[],"schemaVersion":{"major":0,"minor":3,"patch":0},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","anchor":"Overview","text":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"This package implements an atomics library for Swift, providing atomic operations for a variety of Swift types, including integers and pointer values. The goal is to enable intrepid developers to start building synchronization constructs directly in Swift.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Atomic operations aren’t subject to the usual exclusivity rules. The same memory location may be safely read and updated from multiple concurrent threads of execution, as long as all such access is done through atomic operations. For example, here is a trivial atomic counter:"}]},{"type":"codeListing","syntax":"swift","code":["import Atomics","import Dispatch","","let counter = ManagedAtomic<Int>(0)","","DispatchQueue.concurrentPerform(iterations: 10) { _ in","for _ in 0 ..< 1_000_000 {","counter.wrappingIncrement(ordering: .relaxed)","}","}","counter.load(ordering: .relaxed) \/\/ ⟹ 10_000_000"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The only way to access the counter value is to use one of the methods provided by "},{"code":"ManagedAtomic","type":"codeVoice"},{"text":", each of which implement a particular atomic operation, and each of which require an explicit ordering value. (Swift supports a subset of the C\/C++ memory orderings.)","type":"text"}]},{"level":2,"text":"Features","type":"heading","anchor":"Features"},{"inlineContent":[{"text":"The package implements atomic operations for the following Swift constructs, all of which conform to the public ","type":"text"},{"type":"codeVoice","code":"AtomicValue"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Standard signed integer types ("},{"type":"codeVoice","code":"Int"},{"text":", ","type":"text"},{"code":"Int64","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Int32"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Int16"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Int8"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Standard unsigned integer types ("},{"code":"UInt","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UInt64"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UInt32"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UInt16"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Booleans (","type":"text"},{"code":"Bool","type":"codeVoice"},{"type":"text","text":")"}]}]},{"content":[{"inlineContent":[{"text":"Standard pointer types (","type":"text"},{"type":"codeVoice","code":"UnsafeRawPointer"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UnsafeMutableRawPointer"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UnsafePointer<T>"},{"text":", ","type":"text"},{"type":"codeVoice","code":"UnsafeMutablePointer<T>"},{"type":"text","text":"), along with their optional-wrapped forms (such as "},{"type":"codeVoice","code":"Optional<UnsafePointer<T>>"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unmanaged references ("},{"code":"Unmanaged<T>","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Optional<Unmanaged<T>>"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A special "},{"type":"codeVoice","code":"DoubleWord"},{"text":" type that consists of two ","type":"text"},{"type":"codeVoice","code":"UInt"},{"text":" values, ","type":"text"},{"code":"low","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"high"},{"type":"text","text":", providing double-wide atomic primitives"}]}]},{"content":[{"inlineContent":[{"text":"Any ","type":"text"},{"type":"codeVoice","code":"RawRepresentable"},{"text":" type whose ","type":"text"},{"type":"codeVoice","code":"RawValue"},{"text":" is in turn an atomic type (such as simple custom enum types)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Strong references to class instances that opted into atomic use (by conforming to the ","type":"text"},{"type":"codeVoice","code":"AtomicReference"},{"text":" protocol)","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Of particular note is full support for atomic strong references. This provides a convenient memory reclamation solution for concurrent data structures that fits perfectly with Swift’s reference counting memory management model. (Atomic strong references are implemented in terms of ","type":"text"},{"type":"codeVoice","code":"DoubleWord"},{"text":" operations.) However, accessing an atomic strong reference is (relatively) expensive, so we also provide a separate set of efficient constructs (","type":"text"},{"code":"ManagedAtomicLazyReference","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"UnsafeAtomicLazyReference","type":"codeVoice"},{"type":"text","text":") for the common case of a lazily initialized (but otherwise constant) atomic strong reference."}]},{"level":3,"text":"Lock-Free vs Wait-Free Operations","anchor":"Lock-Free-vs-Wait-Free-Operations","type":"heading"},{"inlineContent":[{"text":"All atomic operations exposed by this package are guaranteed to have lock-free implementations. However, we do not guarantee wait-free operation – depending on the capabilities of the target platform, some of the exposed operations may be implemented by compare-and-exchange loops. That said, all atomic operations map directly to dedicated CPU instructions where available – to the extent supported by llvm & Clang.","type":"text"}],"type":"paragraph"},{"text":"Memory Management","type":"heading","anchor":"Memory-Management","level":3},{"inlineContent":[{"type":"text","text":"Atomic access is implemented in terms of dedicated atomic storage representations that are kept distinct from the corresponding regular (non-atomic) type. (E.g., the actual integer value underlying the counter above isn’t directly accessible.) This has several advantages:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"it helps prevent accidental non-atomic access to atomic variables,","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it enables custom storage representations (such as the one used by atomic strong references), and"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"it is a better fit with the standard C atomics library that we use to implement the actual operations (as enabled by "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/master\/proposals\/0282-atomics.md"},{"text":").","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"While the underlying pointer-based atomic operations are exposed as static methods on the corresponding "},{"type":"codeVoice","code":"AtomicStorage"},{"text":" types, we strongly recommend the use of higher-level atomic wrappers to manage the details of preparing\/disposing atomic storage. This version of the library provides two wrapper types:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"an easy to use, memory-safe "},{"code":"ManagedAtomic<T>","type":"codeVoice"},{"text":" generic class and","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"a less convenient, but more flexible ","type":"text"},{"type":"codeVoice","code":"UnsafeAtomic<T>"},{"text":" generic struct.","type":"text"}]}]}]},{"inlineContent":[{"text":"Both constructs provide the following operations on all ","type":"text"},{"code":"AtomicValue","type":"codeVoice"},{"type":"text","text":" types:"}],"type":"paragraph"},{"syntax":"swift","code":["func load(ordering: AtomicLoadOrdering) -> Value","func store(_ desired: Value, ordering: AtomicStoreOrdering)","func exchange(_ desired: Value, ordering: AtomicUpdateOrdering) -> Value","","func compareExchange(","expected: Value,","desired: Value,","ordering: AtomicUpdateOrdering",") -> (exchanged: Bool, original: Value)","","func compareExchange(","expected: Value,","desired: Value,","successOrdering: AtomicUpdateOrdering,","failureOrdering: AtomicLoadOrdering",") -> (exchanged: Bool, original: Value)","","func weakCompareExchange(","expected: Value,","desired: Value,","successOrdering: AtomicUpdateOrdering,","failureOrdering: AtomicLoadOrdering",") -> (exchanged: Bool, original: Value)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Integer types come with additional atomic operations for incrementing or decrementing values and bitwise logical operations. ","type":"text"},{"type":"codeVoice","code":"Bool"},{"text":" provides select additional boolean operations along the same vein.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an introduction to the APIs provided by this package, for now please see the [first version of SE-0282][SE-0282r0]."}]},{"inlineContent":[{"type":"text","text":"Note that when\/if Swift gains support for non-copiable types, we expect to replace both "},{"code":"ManagedAtomic","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"UnsafeAtomic","type":"codeVoice"},{"text":" with a single move-only atomic struct that combines the performance and versatility of ","type":"text"},{"type":"codeVoice","code":"UnsafeAtomic"},{"text":" with the ease-of-use and memory safety of ","type":"text"},{"type":"codeVoice","code":"ManagedAtomic"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The current version of the ","type":"text"},{"type":"codeVoice","code":"Atomics"},{"text":" module does not implement APIs for tagged atomics (see ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-atomics\/issues\/1","type":"reference","isActive":true},{"text":"), although it does expose a ","type":"text"},{"code":"DoubleWord","type":"codeVoice"},{"type":"text","text":" type that can be used to implement them. (Atomic strong references are already implemented in terms of "},{"code":"DoubleWord","type":"codeVoice"},{"type":"text","text":", although in their current form they do not expose any user-customizable bits.)"}]}]}],"kind":"symbol","metadata":{"title":"Atomics","symbolKind":"module","modules":[{"name":"Atomics"}],"roleHeading":"Framework","externalID":"Atomics","role":"collection"},"identifier":{"url":"doc:\/\/Atomics\/documentation\/Atomics","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/atomics"]}],"abstract":[{"text":"An atomics library for Swift.","type":"text"}],"references":{"doc://Atomics/documentation/Atomics/atomicMemoryFence(ordering:)":{"title":"atomicMemoryFence(ordering:)","role":"symbol","url":"\/documentation\/atomics\/atomicmemoryfence(ordering:)","kind":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/atomicMemoryFence(ordering:)","type":"topic","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"atomicMemoryFence","kind":"identifier"},{"kind":"text","text":"("},{"text":"ordering","kind":"externalParam"},{"kind":"text","text":": "},{"text":"AtomicUpdateOrdering","kind":"typeIdentifier","preciseIdentifier":"s:7Atomics20AtomicUpdateOrderingV"},{"text":")","kind":"text"}],"abstract":[{"text":"Establishes a memory ordering without associating it with a","type":"text"},{"text":" ","type":"text"},{"text":"particular atomic operation.","type":"text"}]},"doc://Atomics/documentation/Atomics/AtomicValue":{"type":"topic","url":"\/documentation\/atomics\/atomicvalue","kind":"symbol","abstract":[{"type":"text","text":"A type that supports atomic operations through a separate atomic storage"},{"type":"text","text":" "},{"text":"representation.","type":"text"}],"title":"AtomicValue","navigatorTitle":[{"kind":"identifier","text":"AtomicValue"}],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"AtomicValue","kind":"identifier"}],"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicValue"},"doc://Atomics/documentation/Atomics/AtomicOptionalWrappable":{"abstract":[{"type":"text","text":"An atomic value that also supports atomic operations when wrapped"},{"text":" ","type":"text"},{"text":"in an ","type":"text"},{"type":"codeVoice","code":"Optional"},{"type":"text","text":". Atomic optional wrappable types come with a"},{"text":" ","type":"text"},{"type":"text","text":"standalone atomic representation for their optional-wrapped"},{"type":"text","text":" "},{"type":"text","text":"variants."}],"kind":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicOptionalWrappable","url":"\/documentation\/atomics\/atomicoptionalwrappable","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AtomicOptionalWrappable"}],"navigatorTitle":[{"text":"AtomicOptionalWrappable","kind":"identifier"}],"type":"topic","title":"AtomicOptionalWrappable"},"doc://Atomics/documentation/Atomics/ManagedAtomic":{"url":"\/documentation\/atomics\/managedatomic","abstract":[{"type":"text","text":"A reference type holding an atomic value, with automatic memory management."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ManagedAtomic"}],"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/ManagedAtomic","title":"ManagedAtomic","navigatorTitle":[{"kind":"identifier","text":"ManagedAtomic"}],"type":"topic","role":"symbol"},"doc://Atomics/documentation/Atomics/AtomicStoreOrdering":{"type":"topic","role":"symbol","abstract":[{"text":"Specifies the memory ordering semantics of an atomic store operation.","type":"text"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AtomicStoreOrdering"}],"navigatorTitle":[{"kind":"identifier","text":"AtomicStoreOrdering"}],"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicStoreOrdering","url":"\/documentation\/atomics\/atomicstoreordering","title":"AtomicStoreOrdering","kind":"symbol"},"https://github.com/apple/swift-atomics/issues/1":{"title":"issue #1","titleInlineContent":[{"text":"issue #1","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-atomics\/issues\/1","type":"link","url":"https:\/\/github.com\/apple\/swift-atomics\/issues\/1"},"doc://Atomics/documentation/Atomics":{"type":"topic","url":"\/documentation\/atomics","kind":"symbol","abstract":[{"type":"text","text":"An atomics library for Swift."}],"title":"Atomics","role":"collection","identifier":"doc:\/\/Atomics\/documentation\/Atomics"},"doc://Atomics/documentation/Atomics/ManagedAtomicLazyReference":{"role":"symbol","kind":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/ManagedAtomicLazyReference","abstract":[{"text":"A reference type holding a lazily initializable atomic","type":"text"},{"type":"text","text":" "},{"type":"text","text":"strong reference, with automatic memory management."}],"url":"\/documentation\/atomics\/managedatomiclazyreference","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"ManagedAtomicLazyReference","kind":"identifier"}],"navigatorTitle":[{"text":"ManagedAtomicLazyReference","kind":"identifier"}],"title":"ManagedAtomicLazyReference"},"doc://Atomics/documentation/Atomics/AtomicOptionalRawRepresentableStorage":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"AtomicOptionalRawRepresentableStorage","kind":"identifier"}],"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicOptionalRawRepresentableStorage","url":"\/documentation\/atomics\/atomicoptionalrawrepresentablestorage","abstract":[{"text":"A default atomic storage representation for a ","type":"text"},{"code":"RawRepresentable","type":"codeVoice"},{"type":"text","text":" type"},{"type":"text","text":" "},{"type":"text","text":"whose "},{"type":"codeVoice","code":"RawValue"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"AtomicOptionalWrappable"},{"text":".","type":"text"}],"title":"AtomicOptionalRawRepresentableStorage","type":"topic","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"AtomicOptionalRawRepresentableStorage","kind":"identifier"}]},"https://github.com/apple/swift-evolution/blob/master/proposals/0282-atomics.md":{"title":"SE-0282","titleInlineContent":[{"text":"SE-0282","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/master\/proposals\/0282-atomics.md","type":"link","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/master\/proposals\/0282-atomics.md"},"doc://Atomics/documentation/Atomics/AtomicReference":{"type":"topic","url":"\/documentation\/atomics\/atomicreference","kind":"symbol","abstract":[{"text":"A class type that supports atomic strong references.","type":"text"}],"title":"AtomicReference","navigatorTitle":[{"kind":"identifier","text":"AtomicReference"}],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AtomicReference"}],"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicReference"},"doc://Atomics/documentation/Atomics/AtomicUpdateOrdering":{"title":"AtomicUpdateOrdering","abstract":[{"text":"Specifies the memory ordering semantics of an atomic read-modify-write","type":"text"},{"type":"text","text":" "},{"type":"text","text":"operation."}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"AtomicUpdateOrdering","kind":"identifier"}],"navigatorTitle":[{"text":"AtomicUpdateOrdering","kind":"identifier"}],"type":"topic","url":"\/documentation\/atomics\/atomicupdateordering","role":"symbol","kind":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicUpdateOrdering"},"doc://Atomics/documentation/Atomics/AtomicIntegerStorage":{"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AtomicIntegerStorage","kind":"identifier"}],"abstract":[{"type":"text","text":"The storage representation for an atomic integer value, providing"},{"type":"text","text":" "},{"type":"text","text":"pointer-based atomic operations."}],"url":"\/documentation\/atomics\/atomicintegerstorage","title":"AtomicIntegerStorage","type":"topic","navigatorTitle":[{"text":"AtomicIntegerStorage","kind":"identifier"}],"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicIntegerStorage","role":"symbol"},"doc://Atomics/documentation/Atomics/Swift":{"title":"Swift","type":"topic","url":"\/documentation\/atomics\/swift","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/Swift","role":"collection","abstract":[],"kind":"symbol"},"doc://Atomics/documentation/Atomics/AtomicOptionalReferenceStorage":{"url":"\/documentation\/atomics\/atomicoptionalreferencestorage","navigatorTitle":[{"text":"AtomicOptionalReferenceStorage","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"AtomicOptionalReferenceStorage","kind":"identifier"}],"title":"AtomicOptionalReferenceStorage","kind":"symbol","abstract":[],"role":"symbol","type":"topic","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicOptionalReferenceStorage"},"doc://Atomics/documentation/Atomics/DoubleWord":{"role":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/DoubleWord","title":"DoubleWord","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"DoubleWord"}],"kind":"symbol","url":"\/documentation\/atomics\/doubleword","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"DoubleWord"}]},"doc://Atomics/documentation/Atomics/UnsafeAtomicLazyReference":{"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/UnsafeAtomicLazyReference","title":"UnsafeAtomicLazyReference","url":"\/documentation\/atomics\/unsafeatomiclazyreference","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UnsafeAtomicLazyReference","kind":"identifier"}],"navigatorTitle":[{"text":"UnsafeAtomicLazyReference","kind":"identifier"}],"kind":"symbol","abstract":[{"text":"An unsafe reference type holding a lazily initializable atomic","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"strong reference, requiring manual memory management of the"},{"text":" ","type":"text"},{"type":"text","text":"underlying storage representation."}],"type":"topic"},"doc://Atomics/documentation/Atomics/AtomicLoadOrdering":{"type":"topic","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicLoadOrdering","title":"AtomicLoadOrdering","kind":"symbol","abstract":[{"text":"Specifies the memory ordering semantics of an atomic load operation.","type":"text"}],"role":"symbol","navigatorTitle":[{"text":"AtomicLoadOrdering","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"AtomicLoadOrdering","kind":"identifier"}],"url":"\/documentation\/atomics\/atomicloadordering"},"doc://Atomics/documentation/Atomics/AtomicRawRepresentableStorage":{"identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicRawRepresentableStorage","abstract":[{"text":"The default atomic storage representation for an atomic ","type":"text"},{"code":"RawRepresentable","type":"codeVoice"},{"text":" ","type":"text"},{"text":"type whose ","type":"text"},{"code":"RawValue","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"AtomicValue"},{"text":".","type":"text"}],"navigatorTitle":[{"text":"AtomicRawRepresentableStorage","kind":"identifier"}],"kind":"symbol","title":"AtomicRawRepresentableStorage","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"AtomicRawRepresentableStorage","kind":"identifier"}],"url":"\/documentation\/atomics\/atomicrawrepresentablestorage","role":"symbol"},"doc://Atomics/documentation/Atomics/AtomicInteger":{"abstract":[{"type":"text","text":"A type that supports atomic integer operations through a separate"},{"type":"text","text":" "},{"text":"atomic storage representation.","type":"text"}],"kind":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicInteger","url":"\/documentation\/atomics\/atomicinteger","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AtomicInteger"}],"navigatorTitle":[{"kind":"identifier","text":"AtomicInteger"}],"type":"topic","title":"AtomicInteger"},"doc://Atomics/documentation/Atomics/UnsafeAtomic":{"url":"\/documentation\/atomics\/unsafeatomic","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/UnsafeAtomic","abstract":[{"type":"text","text":"An unsafe reference type holding an atomic value, requiring manual memory"},{"text":" ","type":"text"},{"type":"text","text":"management of the underlying storage representation."}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsafeAtomic"}],"type":"topic","title":"UnsafeAtomic","kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"UnsafeAtomic"}]},"doc://Atomics/documentation/Atomics/AtomicReferenceStorage":{"type":"topic","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicReferenceStorage","title":"AtomicReferenceStorage","kind":"symbol","abstract":[],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AtomicReferenceStorage"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"AtomicReferenceStorage","kind":"identifier"}],"url":"\/documentation\/atomics\/atomicreferencestorage"},"doc://Atomics/documentation/Atomics/AtomicStorage":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AtomicStorage"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/Atomics\/documentation\/Atomics\/AtomicStorage","role":"symbol","abstract":[{"type":"text","text":"The storage representation for an atomic value, providing pointer-based"},{"type":"text","text":" "},{"type":"text","text":"atomic operations. This is a low-level implementation detail of atomic"},{"type":"text","text":" "},{"text":"types; instead of directly handling conforming types, it is usually better","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to use the "},{"code":"UnsafeAtomic","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"ManagedAtomic"},{"type":"text","text":" generics – these provide more"},{"text":" ","type":"text"},{"text":"convenient and safer interfaces while also ensuring that the storage is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"correctly constructed and destroyed."}],"url":"\/documentation\/atomics\/atomicstorage","navigatorTitle":[{"kind":"identifier","text":"AtomicStorage"}],"title":"AtomicStorage"}}}