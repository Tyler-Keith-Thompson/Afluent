{"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","interfaceLanguage":"swift"},"hierarchy":{"paths":[[]]},"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","level":2,"type":"heading","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"This library comes with a number of tools that make working with Swift concurrency easier and more","type":"text"},{"text":" ","type":"text"},{"text":"testable.","type":"text"}]},{"anchor":"LockIsolated","level":3,"text":"LockIsolated","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"LockIsolated"},{"text":" type helps wrap other values in an isolated context. It wraps the value in a","type":"text"},{"text":" ","type":"text"},{"text":"class with a lock, which allows you to read and write the value with a synchronous interface.","type":"text"}]},{"level":3,"text":"Streams","anchor":"Streams","type":"heading"},{"inlineContent":[{"text":"The library comes with numerous helper APIs spread across the two Swift stream types:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"There are helpers that erase any ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" conformance to either concrete stream type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This allows you to treat the stream type as a kind of “type erased” "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"For example, suppose you have a dependency client like this:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct ScreenshotsClient {","  var screenshots: () -> AsyncStream<Void>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you can construct a live implementation that “erases” the"},{"type":"text","text":" "},{"type":"codeVoice","code":"NotificationCenter.Notifications"},{"text":" async sequence to a stream:","type":"text"}]},{"code":["extension ScreenshotsClient {","  static let live = Self(","    screenshots: {","      NotificationCenter.default","        .notifications(named: UIApplication.userDidTakeScreenshotNotification)","        .map { _ in }","        .eraseToStream()  \/\/ ⬅️","    }","  )","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Use "},{"code":"eraseToThrowingStream()","type":"codeVoice"},{"type":"text","text":" to propagate failures from throwing async sequences."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"There is an API for simultaneously constructing a stream and its backing continuation. This can","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"be handy in tests when overriding a dependency endpoint that returns a stream:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let screenshots = AsyncStream<Void>.streamWithContinuation()","let model = FeatureModel(screenshots: screenshots.stream)","","XCTAssertEqual(model.screenshotCount, 0)","screenshots.continuation.yield()  \/\/ Simulate a screenshot being taken.","XCTAssertEqual(model.screenshotCount, 1)"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"type":"codeVoice","code":"AsyncStream.never"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncThrowingStream.never"},{"text":" helpers are provided that represent","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"streams that live forever and never emit. They can be handy in tests that need to override a"},{"text":" ","type":"text"},{"text":"dependency endpoint with a stream that should suspend and never emit for the duration test.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"code":"AsyncStream.finished","type":"codeVoice"},{"type":"text","text":" and "},{"code":"AsyncThrowingStream.finished(throwing:)","type":"codeVoice"},{"type":"text","text":" helpers are provided"},{"type":"text","text":" "},{"type":"text","text":"that represents streams that complete immediately without emitting. They can be handy in tests"},{"text":" ","type":"text"},{"text":"that need to override a dependency endpoint with a stream that completes\/fails immediately.","type":"text"}]}]}]},{"text":"Tasks","level":3,"anchor":"Tasks","type":"heading"},{"inlineContent":[{"type":"text","text":"The library comes with a static function, "},{"code":"Task.never()","type":"codeVoice"},{"text":", that can asynchronously return a value of","type":"text"},{"type":"text","text":" "},{"text":"any type, but does so by suspending forever. This can be useful for satisfying a dependency","type":"text"},{"type":"text","text":" "},{"text":"requirement in a way that does not require you to actually return data from that endpoint.","type":"text"}],"type":"paragraph"},{"text":"UncheckedSendable","level":3,"type":"heading","anchor":"UncheckedSendable"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A wrapper type that can make any type "},{"code":"Sendable","type":"codeVoice"},{"text":", but in an unsafe and unchecked way. This type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"should only be used as an alternative to "},{"type":"codeVoice","code":"@preconcurrency import"},{"type":"text","text":", which turns off concurrency"},{"text":" ","type":"text"},{"type":"text","text":"checks for everything in the library. Whereas "},{"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","type":"reference","isActive":true},{"type":"text","text":" allows you to turn off"},{"text":" ","type":"text"},{"type":"text","text":"concurrency warnings for just one single usage of a particular type."}]},{"inlineContent":[{"text":"While ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","isActive":true},{"type":"text","text":" mentions future work of "},{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","type":"reference","isActive":true},{"type":"text","text":", including an "},{"type":"codeVoice","code":"UnsafeTransfer"},{"text":" type that serves the same","type":"text"},{"text":" ","type":"text"},{"text":"purpose, it has not landed in Swift.","type":"text"}],"type":"paragraph"},{"text":"Serial execution","anchor":"Serial-execution","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some asynchronous code is "},{"type":"reference","identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","isActive":true},{"type":"text","text":" to test in"},{"type":"text","text":" "},{"text":"Swift due to how suspension points are processed by the runtime. The library comes with a static","type":"text"},{"type":"text","text":" "},{"text":"function, ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"type":"text","text":", that runs all tasks spawned in an operation"},{"type":"text","text":" "},{"type":"text","text":"serially and deterministically. This function can be used to make asynchronous tests faster and less"},{"type":"text","text":" "},{"text":"flakey.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Note that running async tasks serially does not mean that multiple concurrent tasks are not able to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"interleave. Suspension of async tasks still works just as you would expect, but all tasks are run on"},{"text":" ","type":"text"},{"text":"the unique, main thread.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For example, consider the following simple ","type":"text"},{"code":"ObservableObject","type":"codeVoice"},{"text":" implementation for a feature that","type":"text"},{"type":"text","text":" "},{"text":"wants to count the number of times a screenshot is taken of the screen:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class FeatureModel: ObservableObject {","  @Published var count = 0","  @MainActor","  func onAppear() async {","    let screenshots = NotificationCenter.default.notifications(","      named: UIApplication.userDidTakeScreenshotNotification","    )","    for await _ in screenshots {","      self.count += 1","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"This is quite a simple feature, but in the future it could start doing more complicated things,","type":"text"},{"text":" ","type":"text"},{"text":"such as performing a network request when it detects a screenshot being taken.","type":"text"}]},{"inlineContent":[{"type":"text","text":"So, it would be great if we could get some test coverage on this feature. To do this we can create"},{"type":"text","text":" "},{"text":"a model, and spin up a new task to invoke the ","type":"text"},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method:"}],"type":"paragraph"},{"syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Then we can use ","type":"text"},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" to allow the subscription of the stream of notifications to start:"}]},{"syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","}"],"type":"codeListing"},{"inlineContent":[{"text":"Then we can simulate the user taking a screenshot by posting a notification:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"And then finally we can yield again to process the new notification and assert that the count"},{"text":" ","type":"text"},{"text":"incremented by 1:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","","  \/\/ Give the task an opportunity to update the view model.","  await Task.yield()","","  XCTAssertEqual(model.count, 1)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This seems like a perfectly reasonable test, and it does pass… sometimes. If you run it enough"},{"type":"text","text":" "},{"text":"times you will eventually get a failure (about 6% of the time). This is happening because sometimes","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the single "},{"code":"Task.yield()","type":"codeVoice"},{"type":"text","text":" is not enough for the subscription to the stream of notifications to"},{"type":"text","text":" "},{"text":"actually start. In that case we will post the notification before we have actually subscribed,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"causing a test failure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we wrap the entire test in "},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"text":", then it will pass","type":"text"},{"type":"text","text":" "},{"type":"text","text":"deterministically, 100% of the time:"}]},{"code":["func testBasics() async {","  await withMainSerialExecutor {","    …","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is because now all tasks are enqueued on the serial, main executor, and so when we "},{"type":"codeVoice","code":"Task.yield"},{"text":" ","type":"text"},{"type":"text","text":"we can be sure that the "},{"code":"onAppear","type":"codeVoice"},{"type":"text","text":" method will execute until it reaches a suspension point. This"},{"type":"text","text":" "},{"text":"guarantees that the subscription to the stream of notifications will start when we expect it to.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can also use ","type":"text"},{"type":"reference","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","isActive":true},{"type":"text","text":" to wrap an entire test case by"},{"text":" ","type":"text"},{"text":"overriding the ","type":"text"},{"type":"codeVoice","code":"invokeTest"},{"type":"text","text":" method:"}]},{"code":["final class FeatureModelTests: XCTestCase {","  override func invokeTest() {","    withMainSerialExecutor {","      super.invokeTest()","    }","  }","  …","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Now the entire "},{"code":"FeatureModelTests","type":"codeVoice"},{"text":" test case will be run on the main, serial executor.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that by using ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"text":" you are technically making your","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"text":" ","type":"text"},{"text":"tests written on a day-to-day basis due not invoke the full-blown vagaries of concurrency. Instead","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the tests want to assert that some user action happens, an async unit of work is executed, and"},{"type":"text","text":" "},{"type":"text","text":"that causes some state to change. Such tests should be written in a way that is 100% deterministic."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your code has truly complex asynchronous and concurrent operations, then it may be handy to write"},{"type":"text","text":" "},{"type":"text","text":"two sets of tests: one set that targets the main executor (using"},{"text":" ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"text":") so that you can deterministically assert how the core","type":"text"},{"type":"text","text":" "},{"text":"system behaves, and then another set that targets the default, global executor that will probably","type":"text"},{"text":" ","type":"text"},{"text":"need to make weaker assertions due to non-determinism, but can still assert on some things.","type":"text"}]}]}],"abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"schemaVersion":{"patch":0,"major":0,"minor":3},"metadata":{"role":"collection","symbolKind":"module","modules":[{"name":"ConcurrencyExtras"}],"title":"ConcurrencyExtras","externalID":"ConcurrencyExtras","roleHeading":"Framework"},"topicSections":[{"identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable"],"anchor":"Data-races","title":"Data races"},{"title":"Serial execution","anchor":"Serial-execution","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"]},{"title":"Preconcurrency","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"],"anchor":"Preconcurrency"},{"generated":true,"identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations"],"title":"Articles","anchor":"Articles"},{"identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolated"],"anchor":"Classes","generated":true,"title":"Classes"},{"identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor"],"anchor":"Variables","generated":true,"title":"Variables"},{"identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1"],"anchor":"Functions","title":"Functions","generated":true},{"generated":true,"identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency"],"title":"Extended Modules","anchor":"Extended-Modules"}],"kind":"symbol","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/concurrencyextras"]}],"sections":[],"references":{"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/AnyHashableSendable":{"url":"\/documentation\/concurrencyextras\/anyhashablesendable","type":"topic","abstract":[{"text":"A type-erased hashable, sendable value.","type":"text"}],"title":"AnyHashableSendable","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnyHashableSendable","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"AnyHashableSendable"}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable","role":"symbol"},"https://forums.swift.org/t/reliably-testing-code-that-adopts-swift-concurrency/57304":{"identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","url":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","type":"link","titleInlineContent":[{"text":"notoriously difficult","type":"text"}],"title":"notoriously difficult"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/UncheckedSendable":{"title":"UncheckedSendable","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UncheckedSendable"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","navigatorTitle":[{"kind":"identifier","text":"UncheckedSendable"}],"url":"\/documentation\/concurrencyextras\/uncheckedsendable","deprecated":true,"abstract":[{"type":"text","text":"A generic wrapper for turning any non-"},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" type into a "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" one, in an unchecked"},{"text":" ","type":"text"},{"text":"manner.","type":"text"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/_Concurrency":{"abstract":[],"title":"_Concurrency","type":"topic","kind":"symbol","url":"\/documentation\/concurrencyextras\/_concurrency","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency","role":"collection"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"url":"\/documentation\/concurrencyextras","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"role":"collection","type":"topic","title":"ConcurrencyExtras","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","kind":"symbol"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md":{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","type":"link","titleInlineContent":[{"text":"SE-0302","type":"text"}],"title":"SE-0302"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ActorIsolated":{"url":"\/documentation\/concurrencyextras\/actorisolated","abstract":[{"text":"A generic wrapper for isolating a mutable value to an actor.","type":"text"}],"fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ActorIsolated"}],"navigatorTitle":[{"text":"ActorIsolated","kind":"identifier"}],"deprecated":true,"role":"symbol","type":"topic","title":"ActorIsolated","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolated","kind":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/LockIsolated":{"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","type":"topic","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"LockIsolated"}],"abstract":[{"text":"A generic wrapper for isolating a mutable value with a lock.","type":"text"}],"url":"\/documentation\/concurrencyextras\/lockisolated","title":"LockIsolated","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"LockIsolated"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/Swift":{"type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","role":"collection","abstract":[],"url":"\/documentation\/concurrencyextras\/swift","title":"Swift","kind":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ActorIsolatedDeprecations":{"url":"\/documentation\/concurrencyextras\/actorisolateddeprecations","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations","abstract":[{"text":"Review unsupported reducer APIs and their replacements.","type":"text"}],"title":"Deprecations","type":"topic","kind":"article","role":"collectionGroup"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases":{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","type":"link","titleInlineContent":[{"text":"“Adaptor Types for Legacy","type":"text"},{"text":" ","type":"text"},{"text":"Codebases”","type":"text"}],"title":"“Adaptor Types for Legacy Codebases”"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-6s3c0":{"fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"withMainSerialExecutor"},{"text":"(","kind":"text"},{"text":"operation","kind":"externalParam"},{"kind":"text","text":": () "},{"text":"async","kind":"keyword"},{"kind":"text","text":" "},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s4Voida","text":"Void"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"keyword","text":"rethrows"}],"url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-6s3c0","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","abstract":[{"text":"Perform an operation on the main serial executor.","type":"text"}],"title":"withMainSerialExecutor(operation:)","type":"topic","kind":"symbol","role":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ReliablyTestingAsync":{"url":"\/documentation\/concurrencyextras\/reliablytestingasync","role":"article","kind":"article","abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"text":" ","type":"text"},{"text":"Swift code.","type":"text"}],"title":"Reliably testing async code","type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/uncheckedUseMainSerialExecutor":{"fragments":[{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"text":"uncheckedUseMainSerialExecutor","kind":"identifier"},{"kind":"text","text":": "},{"preciseIdentifier":"s:Sb","text":"Bool","kind":"typeIdentifier"}],"title":"uncheckedUseMainSerialExecutor","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor","abstract":[{"text":"Overrides Swift’s global executor with the main serial executor in an unchecked fashion.","type":"text"}],"url":"\/documentation\/concurrencyextras\/uncheckedusemainserialexecutor","kind":"symbol","type":"topic","role":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-7fqt1":{"title":"withMainSerialExecutor(operation:)","url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-7fqt1","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"withMainSerialExecutor"},{"text":"(","kind":"text"},{"text":"operation","kind":"externalParam"},{"text":": () ","kind":"text"},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:s4Voida","text":"Void"},{"kind":"text","text":") "},{"text":"rethrows","kind":"keyword"}],"type":"topic","role":"symbol"}}}