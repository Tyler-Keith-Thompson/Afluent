{"primaryContentSections":[{"content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Swift 5.5 brought first class support for concurrency to the language, including lightweight syntax","type":"text"},{"text":" ","type":"text"},{"text":"for describing when functions and methods need to perform async work, a new data type for","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"isolating mutable data, and all new APIs for performing non-blocking asynchronous work. This made it"},{"text":" ","type":"text"},{"type":"text","text":"far easier to write async code than ever before, but it also made testing asynchronous code quite"},{"text":" ","type":"text"},{"text":"a bit more complicated.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Join us for a quick overview of what tools Swift gives us today for testing asynchronous code, as"},{"type":"text","text":" "},{"text":"well as examples of how these tools can fall short, and then how to fix them.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"This article is a brief recap of a "},{"isActive":true,"identifier":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","type":"reference"},{"text":" on Point-Free that","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"goes very deep into how to reliably test async code in Swift."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"type":"heading","text":"Async testing tools of today","anchor":"Async-testing-tools-of-today","level":2},{"inlineContent":[{"type":"text","text":"The primary tool for testing async code today is XCTest’s support for async test cases. Simply mark"},{"type":"text","text":" "},{"type":"text","text":"your test method as "},{"type":"codeVoice","code":"async"},{"type":"text","text":" and then you are free to perform any async work you want:"}],"type":"paragraph"},{"code":["class FeatureTests: XCTestCase {","  func testBasics() async {","    …","  }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This makes it easy to invoke an async function or method and then assert on what changed after"},{"text":" ","type":"text"},{"type":"text","text":"the work finished."}]},{"inlineContent":[{"type":"text","text":"For example, suppose we had a very simple observable object for encapsulating a number that could"},{"type":"text","text":" "},{"type":"text","text":"be incremented and decremented from the UI, as well as the ability to fetch a fact about the"},{"type":"text","text":" "},{"text":"number. The mechanism for fetching the fact should be hidden behind some kind of interface, like","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a protocol, but for now we will pass it as an explicit closure to the model."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Further, to make things interesting, we will also manage a piece of boolean state that tracks","type":"text"},{"type":"text","text":" "},{"type":"text","text":"whether or not the fact is currently loading so that we can display a progress indicator in the"},{"text":" ","type":"text"},{"type":"text","text":"view:"}]},{"syntax":"swift","code":["@MainActor","@Observable","class FeatureModel {","  var count = 0","  var fact: String?","  var isLoadingFact = false","  ","  \/\/ NB: Can hide this closure behind an interface and use some sort of dependency","  \/\/ injection to provide it.","  let numberFact: (Int) async throws -> String","  init(numberFact: @escaping (Int) async throws -> String) {","    self.numberFact = numberFact","  }","  ","  func getFactButtonTapped() async {","    self.isLoadingFact = true ","    defer { self.isLoadingFact = false }","","    do {","      self.fact = try await self.numberFact(self.count)","    } catch {","      \/\/ TODO: Handle error","    } ","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This model seems simple enough, yet it can be surprisingly tricky to test all aspects of it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The easiest part of the model to test is that the "},{"code":"fact","type":"codeVoice"},{"type":"text","text":" state is populated eventually after the"},{"type":"text","text":" "},{"type":"text","text":"“Get fact” button is tapped. That can be done simply thanks to the support for async in tests, and"},{"text":" ","type":"text"},{"text":"by using some kind of “mock” version of the number fact closure that returns a response immediately","type":"text"},{"text":" ","type":"text"},{"text":"rather than making a network request:","type":"text"}]},{"syntax":"swift","code":["@MainActor","func testGetFact() async {","  let model = FeatureModel(numberFact: { number in ","    \"\\(number) is a good number!\" ","  })","  ","  await model.getFactButtonTapped()","  XCAssertEqual(model.fact, \"0 is a good number!\")","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This test will pass 100% of the time, and do so very quickly. And that’s great!"}]},{"inlineContent":[{"text":"What’s not so great is that it’s not really possible to test that the ","type":"text"},{"type":"codeVoice","code":"isLoadingFact"},{"type":"text","text":" state flips"},{"type":"text","text":" "},{"type":"text","text":"from "},{"code":"false","type":"codeVoice"},{"type":"text","text":" to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" and then back to "},{"code":"false","type":"codeVoice"},{"type":"text","text":". At least when using the tools that Swift gives us"},{"text":" ","type":"text"},{"type":"text","text":"today for testing async code."}],"type":"paragraph"},{"inlineContent":[{"text":"First of all, naively asserting on ","type":"text"},{"type":"codeVoice","code":"isLoadingFact"},{"type":"text","text":" right after invoking "},{"type":"codeVoice","code":"getFactButtonTapped"},{"type":"text","text":" can’t"},{"type":"text","text":" "},{"type":"text","text":"possibly work because the async work has already finished by that point:"}],"type":"paragraph"},{"code":["await model.getFactButtonTapped()","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"So what we need to do is run ","type":"text"},{"code":"getFactButtonTapped","type":"codeVoice"},{"text":" in an unstructured ","type":"text"},{"code":"Task","type":"codeVoice"},{"type":"text","text":" so that it can run"},{"text":" ","type":"text"},{"type":"text","text":"in parallel with the rest of the test. That should allow us to wiggle ourselves in between the"},{"text":" ","type":"text"},{"type":"text","text":"moment the boolean state flips to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" and then "},{"code":"false","type":"codeVoice"},{"type":"text","text":":"}]},{"code":["let task = Task { await model.getFactButtonTapped() }","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","await task.value","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However this fails the vast majority of times. Over 99% of the time. It seems that "},{"type":"emphasis","inlineContent":[{"text":"every","type":"text"}]},{"type":"text","text":" once in"},{"type":"text","text":" "},{"type":"text","text":"awhile the "},{"code":"Task","type":"codeVoice"},{"text":" starts up fast enough to flip the boolean to ","type":"text"},{"type":"codeVoice","code":"true"},{"text":", but that is a rare exception","type":"text"},{"type":"text","text":" "},{"type":"text","text":"rather than the rule."}]},{"inlineContent":[{"type":"text","text":"What we really need to do is wait a "},{"inlineContent":[{"text":"little","type":"text"}],"type":"emphasis"},{"text":" bit of time for the ","type":"text"},{"code":"Task","type":"codeVoice"},{"type":"text","text":" to start executing its code,"},{"type":"text","text":" "},{"type":"text","text":"but not "},{"type":"emphasis","inlineContent":[{"type":"text","text":"too"}]},{"text":" much time so that it finishes. Perhaps a single ","type":"text"},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" will help:"}],"type":"paragraph"},{"type":"codeListing","code":["let task = Task { await model.getFactButtonTapped() }","await Task.yield()","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","await task.value","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"],"syntax":"swift"},{"inlineContent":[{"text":"Unfortunately this fails too, and it does so the vast majority of the time.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"And this is only one small example of async code that is difficult to test. If your async code","type":"text"},{"type":"text","text":" "},{"type":"text","text":"tries to implement cancellation, or makes use of time-based asynchrony (such as clocks), or"},{"type":"text","text":" "},{"type":"text","text":"uses async sequences, or any number of things, then you will come across similar test failures that"},{"text":" ","type":"text"},{"text":"are essentially impossible to fix. You may be able to even get the tests to seemingly pass","type":"text"},{"type":"text","text":" "},{"text":"consistently, but almost always if you run them enough times (thousands or millions of times), you","type":"text"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"will"}],"type":"emphasis"},{"type":"text","text":" eventually get a test failure, and that breeds uncertainty in your test suite."}]},{"anchor":"Looking-to-Async-Algorithms-for-inspiration","type":"heading","text":"Looking to Async Algorithms for inspiration","level":2},{"type":"paragraph","inlineContent":[{"text":"So, what are we to do?","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The problem with testing this kind of async code in Swift is that we have no way to predict how"},{"type":"text","text":" "},{"text":"the runtime will schedule and execute work. And that is fine when running the code in production,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but we don’t need that complexity for tests. Most tests are verifying a very simple state machine"},{"type":"text","text":" "},{"type":"text","text":"of actions: the user performs a few actions, one after another, and we assert at each step of the"},{"type":"text","text":" "},{"type":"text","text":"way how the state of our feature changes."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In such situations we don’t need the full power of a complex scheduling machine that manages a small"},{"text":" ","type":"text"},{"text":"pool of threads. It would be completely sufficient to serialize all async work to a single thread.","type":"text"},{"text":" ","type":"text"},{"text":"That does not mean that multiple concurrent tasks are not able to interleave. Suspension of async","type":"text"},{"type":"text","text":" "},{"text":"tasks can still work as you expect, but all actual work is run serially on a single thread.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"And interestingly, there is even a precendent for this in one of Apple’s open source Swift","type":"text"},{"text":" ","type":"text"},{"text":"libraries! The ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms"},{"text":" package comes with an","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","type":"reference","isActive":true},{"text":" library with tools specifically designed","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to make testing async code a deterministic process. It needs this tool in order to write reliable,"},{"type":"text","text":" "},{"text":"deterministic tests for its various operators, such as ","type":"text"},{"type":"codeVoice","code":"debounce"},{"text":", ","type":"text"},{"type":"codeVoice","code":"throttle"},{"text":", and more.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The way it accomplishes this is by "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321"},{"type":"text","text":""},{"text":" ","type":"text"},{"type":"text","text":"that Swift uses when new asynchronous tasks are created. And that hook is publicly exposed to us"},{"text":" ","type":"text"},{"type":"text","text":"from Swift’s actual C++ codebase, which we can see by looking at its "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The async algorithms package uses that global hook to serialize all async work to a single queue"},{"text":" ","type":"text"},{"type":"text","text":"rather than let the test be susceptible to the vagaries of the global concurrent executor, allowing"},{"text":" ","type":"text"},{"text":"it to write tests that pass deterministically, 100% of the time.","type":"text"}]},{"anchor":"How-to-test-async-code-reliably","level":2,"type":"heading","text":"How to test async code reliably?"},{"inlineContent":[{"type":"text","text":"And so if Apple can write tests like this, why can’t we?"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Well, now we can thanks to the "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" tool that ships with"},{"type":"text","text":" "},{"text":"this library. It temporarily alters the manner in which Swift enqueues asynchronous work in order","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to serialize it to the main thread. This allows you to test every facet of the async code, including"},{"text":" ","type":"text"},{"text":"what happens between each suspension point, in a manner that is 100% deterministic.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the previous test we wrote, which passed sometimes but failed most of the times, can"},{"text":" ","type":"text"},{"text":"now be written in a way that passes 100% of the time:","type":"text"}]},{"syntax":"swift","code":["func testGetFact() async {","  await withMainSerialExecutor {","    let model = FeatureModel(numberFact: { number in","      await Task.yield()","      return \"\\(number) is a good number!\" ","    })","    ","    let task = Task { await model.getFactButtonTapped() }","    await Task.yield()","    XCTAssertEqual(model.isLoadingFact, true)  \/\/ ✅","    await task.value","    XCAssertEqual(model.fact, \"0 is a good number!\")  \/\/ ✅","    XCTAssertEqual(model.isLoadingFact, false)  \/\/ ✅","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Because all enqueueing of work has been serialized we can be guaranteed that when we","type":"text"},{"text":" ","type":"text"},{"code":"await Task.yield()","type":"codeVoice"},{"text":" in the test, all work that is suspended will have an opportunity to execute","type":"text"},{"type":"text","text":" "},{"type":"text","text":"before execution is returned to our test. This means this test is guaranteed to always pass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can even override the "},{"type":"codeVoice","code":"invokeTest"},{"type":"text","text":" method in your test case to force every test to run on the"},{"text":" ","type":"text"},{"text":"main serial executor:","type":"text"}]},{"code":["override func invokeTest() {","  withMainSerialExecutor {","    super.invokeTest()","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This tool allows you to finally write tests against complex and subtle async code that you can be"},{"text":" ","type":"text"},{"text":"confident in. No more seeing mysterious test failures on CI and wasting hours of CI time re-running","type":"text"},{"type":"text","text":" "},{"type":"text","text":"tests or hours of developer time investigating if they are true errors or simply flakiness in the"},{"type":"text","text":" "},{"text":"async scheduling.","type":"text"}],"type":"paragraph"},{"type":"heading","level":2,"text":"Testing reality","anchor":"Testing-reality"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that by using "},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"type":"text","text":" you are technically making your"},{"text":" ","type":"text"},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"text":" ","type":"text"},{"text":"tests written on a day-to-day basis do not invoke the full-blown vagaries of concurrency. Instead,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"tests often want to assert that when some user action happens, an async unit of work is executed,"},{"type":"text","text":" "},{"text":"and that causes some state to change. Such tests should be written in a way that is 100%","type":"text"},{"type":"text","text":" "},{"type":"text","text":"deterministic. And even Apple agrees in their "},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","type":"reference","isActive":true},{"type":"text","text":" where they justify why they think their manner of"},{"type":"text","text":" "},{"type":"text","text":"testing async sequences truly does test reality even though they are altering the runtime that"},{"type":"text","text":" "},{"type":"text","text":"schedules async work (emphasis ours):"}]},{"name":"Quote from AsyncAlgorithms","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Testing is a critical area of focus for any package to make it","type":"text"},{"text":" ","type":"text"},{"text":"robust, catch bugs, and explain the expected behaviors in a documented manner. Testing things that","type":"text"},{"type":"text","text":" "},{"text":"are asynchronous can be difficult, testing things that are asynchronous multiple times can be even","type":"text"},{"text":" ","type":"text"},{"text":"more difficult.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Types that implement AsyncSequence "},{"type":"strong","inlineContent":[{"type":"text","text":"can often be described in deterministic actions given"},{"text":" ","type":"text"},{"text":"particular inputs","type":"text"}]},{"type":"text","text":". For the inputs, the events can be described as a discrete set: values, errors"},{"type":"text","text":" "},{"text":"being thrown, the terminal state of returning a nil value from the iterator, or advancing in time","type":"text"},{"text":" ","type":"text"},{"text":"and not doing anything. Likewise, the expected output has a discrete set of events: values, errors","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"being caught, the terminal state of receiving a nil value from the iterator, or advancing in time"},{"type":"text","text":" "},{"text":"and not doing anything.","type":"text"}]}]}],"type":"aside"},{"inlineContent":[{"type":"text","text":"Just as async sequences can often be described with a determinstic sequences of inputs that lead to"},{"text":" ","type":"text"},{"text":"a deterministic sequence of outputs, the same is true of user actions in an application. And so we","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"too feel that many of the tests we write on a daily basis can be run inside"},{"text":" ","type":"text"},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" and that we are not weakening the strength of those"},{"type":"text","text":" "},{"type":"text","text":"tests in the least."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, if your code has truly complex asynchronous and concurrent operations, then it may be handy"},{"text":" ","type":"text"},{"type":"text","text":"to write two sets of tests: one set that targets the main executor (using "},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"so that you can deterministically assert how the core system behaves, and then another set that"},{"type":"text","text":" "},{"text":"targets the default, global executor. The latter tests will probably need to make weaker assertions","type":"text"},{"type":"text","text":" "},{"text":"due to non-determinism, but can still assert on some things.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"variants":[{"paths":["\/documentation\/concurrencyextras\/reliablytestingasync"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"type":"text","text":" "},{"type":"text","text":"Swift code."}],"metadata":{"modules":[{"name":"ConcurrencyExtras"}],"role":"article","title":"Reliably testing async code","roleHeading":"Article"},"kind":"article","sections":[],"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras"]]},"references":{"https://github.com/apple/swift/blob/e89de6e7e0952c3d0485cc07129ec17f2763c12f/include/swift/Runtime/Concurrency.h#L734-L738":{"title":"headers","identifier":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738","url":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738","titleInlineContent":[{"text":"headers","type":"text"}],"type":"link"},"https://github.com/apple/swift-async-algorithms/blob/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation/Test.swift#L319-L321":{"title":"overriding the global enqueue hook","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321","titleInlineContent":[{"text":"overriding the global enqueue hook","type":"text"}],"type":"link"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"url":"\/documentation\/concurrencyextras","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"role":"collection","type":"topic","title":"ConcurrencyExtras","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","kind":"symbol"},"https://github.com/apple/swift-async-algorithms/blob/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation/AsyncSequenceValidation.docc/AsyncSequenceValidation.md":{"title":"documentation of AsyncSequenceValidation","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","titleInlineContent":[{"text":"documentation of","type":"text"},{"type":"text","text":" "},{"code":"AsyncSequenceValidation","type":"codeVoice"}],"type":"link"},"https://github.com/apple/swift-async-algorithms":{"title":"Async Algorithms","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms","url":"https:\/\/github.com\/apple\/swift-async-algorithms","titleInlineContent":[{"text":"Async Algorithms","type":"text"}],"type":"link"},"https://github.com/apple/swift-async-algorithms/tree/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation":{"title":"AsyncSequenceValidation","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","titleInlineContent":[{"code":"AsyncSequenceValidation","type":"codeVoice"}],"type":"link"},"https://www.pointfree.co/collections/concurrency/testing-async-code":{"title":"series of episodes","identifier":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","url":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","titleInlineContent":[{"text":"series of","type":"text"},{"type":"text","text":" "},{"text":"episodes","type":"text"}],"type":"link"}}}